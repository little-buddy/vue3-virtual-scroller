{"version":3,"file":"vue3-virtual-scroller.min.js","sources":["../src/config.js","../node_modules/vue3-resize/dist/vue3-resize.esm.js","../node_modules/vue3-observe-visibility2/dist/vue3-observe-visibility2.esm.js","../src/components/common.js","../src/utils.js","../src/components/RecycleScroller.vue","../src/components/RecycleScroller.vue?vue&type=template&id=093a936d&lang.js","../src/components/DynamicScroller.vue","../src/components/DynamicScroller.vue?vue&type=template&id=76e15f19&lang.js","../src/components/DynamicScrollerItem.js","../src/index.js"],"sourcesContent":["export default {\n  itemsLimit: 1000,\n}\n","import { ref, onMounted, onBeforeUnmount, openBlock, createBlock } from 'vue';\n\nfunction getInternetExplorerVersion() {\n  const ua = window.navigator.userAgent;\n  const msie = ua.indexOf('MSIE ');\n\n  if (msie > 0) {\n    // IE 10 or older => return version number\n    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n  }\n\n  const trident = ua.indexOf('Trident/');\n\n  if (trident > 0) {\n    // IE 11 => return version number\n    const rv = ua.indexOf('rv:');\n    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n  }\n\n  const edge = ua.indexOf('Edge/');\n\n  if (edge > 0) {\n    // Edge (IE 12+) => return version number\n    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n  } // other browser\n\n\n  return -1;\n}\n\nlet isIE;\n\nfunction initCompat() {\n  if (!initCompat.init) {\n    initCompat.init = true;\n    isIE = getInternetExplorerVersion() !== -1;\n  }\n}\n\nvar script = {\n  name: 'ResizeObserver',\n  props: {\n    showTrigger: {\n      type: Boolean,\n      default: false\n    }\n  },\n  emits: ['notify'],\n\n  setup(props, {\n    emit\n  }) {\n    let _w = 0;\n    let _h = 0;\n    const elRef = ref(null);\n    let _resizeObject = null;\n\n    const compareAndNotify = () => {\n      if (_w !== elRef.value.offsetWidth || _h !== elRef.value.offsetHeight) {\n        _w = elRef.value.offsetWidth;\n        _h = elRef.value.offsetHeight;\n        emit('notify', {\n          width: _w,\n          height: _h\n        });\n      }\n    };\n\n    const addResizeHandlers = () => {\n      _resizeObject.contentDocument.defaultView.addEventListener('resize', compareAndNotify);\n\n      compareAndNotify();\n    };\n\n    const removeResizeHandlers = () => {\n      if (_resizeObject && _resizeObject.onload) {\n        if (!isIE && _resizeObject.contentDocument) {\n          _resizeObject.contentDocument.defaultView.removeEventListener('resize', compareAndNotify);\n        }\n\n        elRef.value.removeChild(_resizeObject);\n        _resizeObject.onload = null;\n        _resizeObject = null;\n      }\n    };\n\n    onMounted(() => {\n      initCompat();\n      _w = elRef.value.offsetWidth;\n      _h = elRef.value.offsetHeight;\n      const object = document.createElement('object');\n      _resizeObject = object;\n      object.setAttribute('aria-hidden', 'true');\n      object.setAttribute('tabindex', '-1');\n      object.onload = addResizeHandlers;\n      object.type = 'text/html';\n\n      if (isIE) {\n        elRef.value.appendChild(object);\n      }\n\n      object.data = 'about:blank';\n\n      if (!isIE) {\n        elRef.value.appendChild(object);\n      }\n\n      if (props.showTrigger) {\n        compareAndNotify();\n      }\n    });\n    onBeforeUnmount(() => {\n      removeResizeHandlers();\n    });\n    return {\n      elRef\n    };\n  }\n\n};\n\nconst _hoisted_1 = {\n  ref: \"elRef\",\n  class: \"vue3-resize-observer\",\n  tabindex: \"-1\"\n};\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createBlock(\"div\", _hoisted_1, null, 512\n  /* NEED_PATCH */\n  );\n}\n\nscript.render = render;\nscript.__file = \"src/package/ResizeObserver/ResizeObserver.vue\";\n\nscript.install = function (app) {\n  app.component(script.name, script);\n};\n\nvar version = \"0.2.0\";\n\nconst install = app => {\n  app.use(script);\n}; // Plugin\n\n\nconst Vue3Resize = {\n  version,\n  install\n};\n\nexport default Vue3Resize;\nexport { script as ResizeObserver, install };\n//# sourceMappingURL=vue3-resize.esm.js.map\n","function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction processOptions(value) {\n  var options;\n\n  if (typeof value === 'function') {\n    // Simple options (callback-only)\n    options = {\n      callback: value\n    };\n  } else {\n    // Options object\n    options = value;\n  }\n\n  return options;\n}\nfunction throttle(callback, delay) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var timeout;\n  var lastState;\n  var currentArgs;\n\n  var throttled = function throttled(state) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    currentArgs = args;\n    if (timeout && state === lastState) return;\n    var leading = options.leading;\n\n    if (typeof leading === 'function') {\n      leading = leading(state, lastState);\n    }\n\n    if ((!timeout || state !== lastState) && leading) {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n    }\n\n    lastState = state;\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n      timeout = 0;\n    }, delay);\n  };\n\n  throttled._clear = function () {\n    clearTimeout(timeout);\n    timeout = null;\n  };\n\n  return throttled;\n}\nfunction deepEqual(val1, val2) {\n  if (val1 === val2) return true;\n\n  if (_typeof(val1) === 'object') {\n    // eslint-disable-next-line no-restricted-syntax\n    for (var key in val1) {\n      if (!deepEqual(val1[key], val2[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nvar VisibilityState =\n/*#__PURE__*/\nfunction () {\n  function VisibilityState(el, options, vnode) {\n    _classCallCheck(this, VisibilityState);\n\n    this.el = el;\n    this.observer = null;\n    this.frozen = false;\n    this.createObserver(options, vnode);\n  }\n\n  _createClass(VisibilityState, [{\n    key: \"createObserver\",\n    value: function createObserver(options) {\n      var _this = this;\n\n      if (this.observer) {\n        this.destroyObserver();\n      }\n\n      if (this.frozen) return;\n      this.options = processOptions(options);\n\n      this.callback = function (result, entry) {\n        _this.options.callback(result, entry);\n\n        if (result && _this.options.once) {\n          _this.frozen = true;\n\n          _this.destroyObserver();\n        }\n      }; // Throttle\n\n\n      if (this.callback && this.options.throttle) {\n        var _ref = this.options.throttleOptions || {},\n            _leading = _ref.leading;\n\n        this.callback = throttle(this.callback, this.options.throttle, {\n          leading: function leading(state) {\n            return _leading === 'both' || _leading === 'visible' && state || _leading === 'hidden' && !state;\n          }\n        });\n      }\n\n      this.oldResult = undefined;\n      this.observer = new IntersectionObserver(function (entries) {\n        var entry = entries[0];\n\n        if (entries.length > 1) {\n          var intersectingEntry = entries.find(function (e) {\n            return e.isIntersecting;\n          });\n\n          if (intersectingEntry) {\n            entry = intersectingEntry;\n          }\n        }\n\n        if (_this.callback) {\n          // Use isIntersecting if possible because browsers can report isIntersecting as true, but intersectionRatio as 0, when something very slowly enters the viewport.\n          var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;\n          if (result === _this.oldResult) return;\n          _this.oldResult = result;\n\n          _this.callback(result, entry);\n        }\n      }, this.options.intersection); // Wait for the element to be in document\n\n      setTimeout(function () {\n        if (_this.observer) {\n          _this.observer.observe(_this.el);\n        }\n      });\n    }\n  }, {\n    key: \"destroyObserver\",\n    value: function destroyObserver() {\n      if (this.observer) {\n        this.observer.disconnect();\n        this.observer = null;\n      } // Cancel throttled call\n\n\n      if (this.callback && this.callback._clear) {\n        this.callback._clear();\n\n        this.callback = null;\n      }\n    }\n  }, {\n    key: \"threshold\",\n    get: function get() {\n      return this.options.intersection && this.options.intersection.threshold || 0;\n    }\n  }]);\n\n  return VisibilityState;\n}();\n\nfunction mounted(el, _ref2, vnode) {\n  var value = _ref2.value;\n  if (!value) return;\n\n  if (typeof IntersectionObserver === 'undefined') {\n    console.warn('[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill');\n  } else {\n    var state = new VisibilityState(el, value, vnode);\n    el._vue_visibilityState = state;\n  }\n}\n\nfunction unmounted(el) {\n  var state = el._vue_visibilityState;\n\n  if (state) {\n    state.destroyObserver();\n    delete el._vue_visibilityState;\n  }\n}\n\nfunction componentUpdated(el, _ref3, vnode) {\n  var value = _ref3.value,\n      oldValue = _ref3.oldValue;\n  if (deepEqual(value, oldValue)) return;\n  var state = el._vue_visibilityState;\n\n  if (!value) {\n    unmounted(el);\n    return;\n  }\n\n  if (state) {\n    state.createObserver(value, vnode);\n  } else {\n    mounted(el, {\n      value: value\n    }, vnode);\n  }\n}\n\nvar ObserveVisibility = {\n  mounted: mounted,\n  componentUpdated: componentUpdated,\n  unmounted: unmounted\n};\n\nvar version = \"0.0.3\";\n\nvar install = function install(app) {\n  app.use({\n    // eslint-disable-next-line no-shadow\n    install: function install(app) {\n      app.directive('observe-visibility', ObserveVisibility);\n    }\n  });\n}; // Plugin\n\n\nvar plugin = {\n  version: version,\n  install: install\n};\n\nexport default plugin;\nexport { ObserveVisibility, install };\n","export const props = {\n  items: {\n    type: Array,\n    required: true,\n  },\n\n  keyField: {\n    type: String,\n    default: 'id',\n  },\n\n  direction: {\n    type: String,\n    default: 'vertical',\n    validator: (value) => ['vertical', 'horizontal'].includes(value),\n  },\n}\n\nexport const scrollParent = (node) => {\n  const regex = /(auto|scroll)/;\n\n  function parents (node, ps) {\n    if (node.parentNode === null) { return ps; }\n    return parents(node.parentNode, ps.concat([node]));\n  }\n\n  function style (node, prop) {\n    return getComputedStyle(node, null).getPropertyValue(prop);\n  }\n\n  function overflow (node) {\n    return style(node, \"overflow\") + style(node, \"overflow-y\") + style(node, \"overflow-x\");\n  }\n\n  function scroll (node) {\n    return regex.test(overflow(node));\n  }\n\n  function scrollParent (node) {\n    if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n      return ;\n    }\n\n    const ps = parents(node.parentNode, []);\n\n    for (let i = 0; i < ps.length; i += 1) {\n      if (scroll(ps[i])) {\n        return ps[i];\n      }\n    }\n\n    return document.scrollingElement || document.documentElement;\n  }\n\n  return scrollParent(node);\n}\n\nexport function simpleArray () {\n  return this.items.length && typeof this.items[0] !== 'object'\n}\n","export let supportsPassive = false\n\nif (typeof window !== 'undefined') {\n  supportsPassive = false\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get () {\n        supportsPassive = true\n      },\n    })\n    window.addEventListener('test', null, opts)\n  } catch (e) {}\n}\n","<template>\n  <div\n    v-observe-visibility=\"handleVisibilityChange\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      'page-mode': pageMode,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <div v-if=\"$slots.before\" class=\"vue-recycle-scroller__slot\">\n      <slot name=\"before\" />\n    </div>\n\n    <div\n      ref=\"wrapper\"\n      :style=\"{\n        [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px',\n      }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n    >\n      <div\n        v-for=\"view of pool\"\n        :key=\"view.nr.id\"\n        :style=\"\n          ready\n            ? {\n                transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${\n                  view.position\n                }px)`,\n              }\n            : null\n        \"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"{ hover: hoverKey === view.nr.key }\"\n        @mouseenter=\"hoverKey = view.nr.key\"\n        @mouseleave=\"hoverKey = null\"\n      >\n        <slot :item=\"view.item\" :index=\"view.nr.index\" :active=\"view.nr.used\" />\n      </div>\n    </div>\n\n    <div v-if=\"$slots.after\" class=\"vue-recycle-scroller__slot\">\n      <slot name=\"after\" />\n    </div>\n\n    <ResizeObserver @notify=\"handleResize\" />\n  </div>\n</template>\n\n<script>\nimport { ResizeObserver } from \"vue3-resize\";\nimport { ObserveVisibility } from \"vue3-observe-visibility2\";\nimport config from \"../config\";\nimport { props, simpleArray, scrollParent } from \"./common\";\nimport { supportsPassive } from \"../utils\";\nimport { defineComponent } from \"vue\";\n\nlet uid = 0;\n\nexport default defineComponent({\n  name: \"RecycleScroller\",\n\n  components: {\n    ResizeObserver,\n  },\n\n  directives: {\n    ObserveVisibility,\n  },\n\n  props: {\n    ...props,\n\n    itemSize: {\n      type: Number,\n      default: null,\n    },\n\n    minItemSize: {\n      type: [Number, String],\n      default: null,\n    },\n\n    sizeField: {\n      type: String,\n      default: \"size\",\n    },\n\n    typeField: {\n      type: String,\n      default: \"type\",\n    },\n\n    buffer: {\n      type: Number,\n      default: 200,\n    },\n\n    pageMode: {\n      type: Boolean,\n      default: false,\n    },\n\n    prerender: {\n      type: Number,\n      default: 0,\n    },\n\n    emitUpdate: {\n      type: Boolean,\n      default: false,\n    },\n  },\n\n  emits: [\"visible\", \"hidden\", \"resize\", \"update\", \"bottom\"],\n\n  data() {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null,\n    };\n  },\n\n  computed: {\n    sizes() {\n      if (this.itemSize === null) {\n        const sizes = {\n          \"-1\": { accumulator: 0 },\n        };\n        const items = this.items;\n        const field = this.sizeField;\n        const minItemSize = this.minItemSize;\n        let computedMinSize = 10000;\n        let accumulator = 0;\n        let current;\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize;\n          if (current < computedMinSize) {\n            computedMinSize = current;\n          }\n          accumulator += current;\n          sizes[i] = { accumulator, size: current };\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize;\n        return sizes;\n      }\n      return [];\n    },\n\n    simpleArray,\n  },\n\n  watch: {\n    items() {\n      this.updateVisibleItems(true);\n    },\n\n    pageMode() {\n      this.applyPageMode();\n      this.updateVisibleItems(false);\n    },\n\n    sizes: {\n      handler() {\n        this.updateVisibleItems(false);\n      },\n      deep: true,\n    },\n  },\n\n  created() {\n    this.$_startIndex = 0;\n    this.$_endIndex = 0;\n    this.$_views = new Map();\n    this.$_unusedViews = new Map();\n    this.$_scrollDirty = false;\n    this.$_lastUpdateScrollPosition = 0;\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true;\n      this.updateVisibleItems(false);\n    }\n  },\n\n  mounted() {\n    this.applyPageMode();\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false;\n      this.updateVisibleItems(true);\n      this.ready = true;\n    });\n  },\n\n  beforeUnmount() {\n    this.removeListeners();\n  },\n\n  methods: {\n    addView(pool, index, item, key, type) {\n      const view = {\n        item,\n        position: 0,\n      };\n      view.nr = {\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      };\n      pool.push(view);\n      return view;\n    },\n\n    unuseView(view, fake = false) {\n      const unusedViews = this.$_unusedViews;\n      const type = view.nr.type;\n      let unusedPool = unusedViews.get(type);\n      if (!unusedPool) {\n        unusedPool = [];\n        unusedViews.set(type, unusedPool);\n      }\n      unusedPool.push(view);\n      if (!fake) {\n        view.nr.used = false;\n        view.position = -9999;\n        this.$_views.delete(view.nr.key);\n      }\n    },\n\n    handleResize() {\n      this.$emit(\"resize\");\n      if (this.ready) this.updateVisibleItems(false);\n    },\n\n    handleScroll(event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true;\n        requestAnimationFrame(() => {\n          this.$_scrollDirty = false;\n          const { continuous } = this.updateVisibleItems(false, true);\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout);\n            this.$_refreshTimout = setTimeout(this.handleScroll, 100);\n          }\n        });\n      }\n    },\n\n    handleVisibilityChange(isVisible, entry) {\n      if (this.ready) {\n        if (\n          isVisible ||\n          entry.boundingClientRect.width !== 0 ||\n          entry.boundingClientRect.height !== 0\n        ) {\n          this.$emit(\"visible\");\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false);\n          });\n        } else {\n          this.$emit(\"hidden\");\n        }\n      }\n    },\n\n    updateVisibleItems(checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize;\n      const minItemSize = this.$_computedMinItemSize;\n      const typeField = this.typeField;\n      const keyField = this.simpleArray ? null : this.keyField;\n      const items = this.items;\n      const count = items.length;\n      const sizes = this.sizes;\n      const views = this.$_views;\n      const unusedViews = this.$_unusedViews;\n      const pool = this.pool;\n      let startIndex, endIndex;\n      let totalSize;\n\n      if (!count) {\n        startIndex = endIndex = totalSize = 0;\n      } else if (this.$_prerender) {\n        startIndex = 0;\n        endIndex = this.prerender;\n        totalSize = null;\n      } else {\n        const scroll = this.getScroll();\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition;\n          if (positionDiff < 0) positionDiff = -positionDiff;\n          if (\n            (itemSize === null && positionDiff < minItemSize) ||\n            positionDiff < itemSize\n          ) {\n            return {\n              continuous: true,\n            };\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start;\n\n        const buffer = this.buffer;\n        scroll.start -= buffer;\n        scroll.end += buffer;\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h;\n          let a = 0;\n          let b = count - 1;\n          let i = ~~(count / 2);\n          let oldI;\n\n          // Searching for startIndex\n          do {\n            oldI = i;\n            h = sizes[i].accumulator;\n            if (h < scroll.start) {\n              a = i;\n            } else if (\n              i < count - 1 &&\n              sizes[i + 1].accumulator > scroll.start\n            ) {\n              b = i;\n            }\n            i = ~~((a + b) / 2);\n          } while (i !== oldI);\n          i < 0 && (i = 0);\n          startIndex = i;\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator;\n\n          // Searching for endIndex\n          for (\n            endIndex = i;\n            endIndex < count && sizes[endIndex].accumulator < scroll.end;\n            endIndex++\n          );\n          if (endIndex === -1) {\n            endIndex = items.length - 1;\n          } else {\n            endIndex++;\n            // Bounds\n            endIndex > count && (endIndex = count);\n          }\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize);\n          endIndex = Math.ceil(scroll.end / itemSize);\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0);\n          endIndex > count && (endIndex = count);\n\n          totalSize = count * itemSize;\n        }\n      }\n\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError();\n      }\n\n      this.totalSize = totalSize;\n\n      let view;\n\n      const continuous =\n        startIndex <= this.$_endIndex && endIndex >= this.$_startIndex;\n\n      if (this.$_continuous !== continuous) {\n        if (continuous) {\n          views.clear();\n          unusedViews.clear();\n          for (let i = 0, l = pool.length; i < l; i++) {\n            view = pool[i];\n            this.unuseView(view);\n          }\n        }\n        this.$_continuous = continuous;\n      } else if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i];\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = items.findIndex((item) =>\n                keyField\n                  ? item[keyField] === view.item[keyField]\n                  : item === view.item\n              );\n            }\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index === -1 ||\n              view.nr.index < startIndex ||\n              view.nr.index >= endIndex\n            ) {\n              this.unuseView(view);\n            }\n          }\n        }\n      }\n\n      const unusedIndex = continuous ? null : new Map();\n\n      let item, type, unusedPool;\n      let v;\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i];\n        const key = keyField ? item[keyField] : item;\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`);\n        }\n        view = views.get(key);\n\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view);\n          continue;\n        }\n\n        // No view assigned to item\n        if (!view) {\n          type = item[typeField];\n          unusedPool = unusedViews.get(type);\n\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop();\n              view.item = item;\n              view.nr.used = true;\n              view.nr.index = i;\n              view.nr.key = key;\n              view.nr.type = type;\n            } else {\n              view = this.addView(pool, i, item, key, type);\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0;\n\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type);\n              this.unuseView(view, true);\n              unusedPool = unusedViews.get(type);\n            }\n\n            view = unusedPool[v];\n            view.item = item;\n            view.nr.used = true;\n            view.nr.index = i;\n            view.nr.key = key;\n            view.nr.type = type;\n            unusedIndex.set(type, v + 1);\n            v++;\n          }\n          views.set(key, view);\n        } else {\n          view.nr.used = true;\n          view.item = item;\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator;\n        } else {\n          view.position = i * itemSize;\n        }\n      }\n\n      this.$_startIndex = startIndex;\n      this.$_endIndex = endIndex;\n\n      if (this.emitUpdate) this.$emit(\"update\", startIndex, endIndex);\n\n      if (endIndex === this.items.length)\n        this.$emit(\"bottom\", startIndex, endIndex);\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer);\n      this.$_sortTimer = setTimeout(this.sortViews, 300);\n\n      return {\n        continuous,\n      };\n    },\n\n    getListenerTarget() {\n      let target = scrollParent(this.$el);\n      // Fix global scroll target for Chrome and Safari\n      if (\n        window.document &&\n        (target === window.document.documentElement ||\n          target === window.document.body)\n      ) {\n        target = window;\n      }\n      return target;\n    },\n\n    getScroll() {\n      const { $el: el, direction } = this;\n      const isVertical = direction === \"vertical\";\n      let scrollState;\n\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect();\n        const boundsSize = isVertical ? bounds.height : bounds.width;\n        let start = -(isVertical ? bounds.top : bounds.left);\n        let size = isVertical ? window.innerHeight : window.innerWidth;\n        if (start < 0) {\n          size += start;\n          start = 0;\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start;\n        }\n        scrollState = {\n          start,\n          end: start + size,\n        };\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight,\n        };\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth,\n        };\n      }\n\n      return scrollState;\n    },\n\n    applyPageMode() {\n      if (this.pageMode) {\n        this.addListeners();\n      } else {\n        this.removeListeners();\n      }\n    },\n\n    addListeners() {\n      this.listenerTarget = this.getListenerTarget();\n      this.listenerTarget.addEventListener(\n        \"scroll\",\n        this.handleScroll,\n        supportsPassive\n          ? {\n              passive: true,\n            }\n          : false\n      );\n      this.listenerTarget.addEventListener(\"resize\", this.handleResize);\n    },\n\n    removeListeners() {\n      if (!this.listenerTarget) {\n        return;\n      }\n\n      this.listenerTarget.removeEventListener(\"scroll\", this.handleScroll);\n      this.listenerTarget.removeEventListener(\"resize\", this.handleResize);\n\n      this.listenerTarget = null;\n    },\n\n    scrollToItem(index) {\n      let scroll;\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0;\n      } else {\n        scroll = index * this.itemSize;\n      }\n      this.scrollToPosition(scroll);\n    },\n\n    scrollToPosition(position) {\n      if (this.direction === \"vertical\") {\n        this.$el.scrollTop = position;\n      } else {\n        this.$el.scrollLeft = position;\n      }\n    },\n\n    itemsLimitError() {\n      setTimeout(() => {\n        console.log(\n          \"It seems the scroller element isn't scrolling, so it tries to render all the items at once.\",\n          \"Scroller:\",\n          this.$el\n        );\n        console.log(\n          \"Make sure the scroller has a fixed height (or width) and 'overflow-y' (or 'overflow-x') set to 'auto' so it can scroll correctly and only render the items visible in the scroll viewport.\"\n        );\n      });\n      throw new Error(\"Rendered items limit reached\");\n    },\n\n    sortViews() {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index);\n    },\n  },\n});\n</script>\n\n<style>\n.vue-recycle-scroller {\n  position: relative;\n}\n\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n  overflow-x: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal {\n  display: flex;\n}\n\n.vue-recycle-scroller__slot {\n  flex: auto 0 0;\n}\n\n.vue-recycle-scroller__item-wrapper {\n  flex: 1;\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n}\n\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n  width: 100%;\n}\n\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n  height: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-vertical\n  .vue-recycle-scroller__item-view {\n  width: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-horizontal\n  .vue-recycle-scroller__item-view {\n  height: 100%;\n}\n</style>\n","<template>\n  <div\n    v-observe-visibility=\"handleVisibilityChange\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      'page-mode': pageMode,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <div v-if=\"$slots.before\" class=\"vue-recycle-scroller__slot\">\n      <slot name=\"before\" />\n    </div>\n\n    <div\n      ref=\"wrapper\"\n      :style=\"{\n        [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px',\n      }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n    >\n      <div\n        v-for=\"view of pool\"\n        :key=\"view.nr.id\"\n        :style=\"\n          ready\n            ? {\n                transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${\n                  view.position\n                }px)`,\n              }\n            : null\n        \"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"{ hover: hoverKey === view.nr.key }\"\n        @mouseenter=\"hoverKey = view.nr.key\"\n        @mouseleave=\"hoverKey = null\"\n      >\n        <slot :item=\"view.item\" :index=\"view.nr.index\" :active=\"view.nr.used\" />\n      </div>\n    </div>\n\n    <div v-if=\"$slots.after\" class=\"vue-recycle-scroller__slot\">\n      <slot name=\"after\" />\n    </div>\n\n    <ResizeObserver @notify=\"handleResize\" />\n  </div>\n</template>\n\n<script>\nimport { ResizeObserver } from \"vue3-resize\";\nimport { ObserveVisibility } from \"vue3-observe-visibility2\";\nimport config from \"../config\";\nimport { props, simpleArray, scrollParent } from \"./common\";\nimport { supportsPassive } from \"../utils\";\nimport { defineComponent } from \"vue\";\n\nlet uid = 0;\n\nexport default defineComponent({\n  name: \"RecycleScroller\",\n\n  components: {\n    ResizeObserver,\n  },\n\n  directives: {\n    ObserveVisibility,\n  },\n\n  props: {\n    ...props,\n\n    itemSize: {\n      type: Number,\n      default: null,\n    },\n\n    minItemSize: {\n      type: [Number, String],\n      default: null,\n    },\n\n    sizeField: {\n      type: String,\n      default: \"size\",\n    },\n\n    typeField: {\n      type: String,\n      default: \"type\",\n    },\n\n    buffer: {\n      type: Number,\n      default: 200,\n    },\n\n    pageMode: {\n      type: Boolean,\n      default: false,\n    },\n\n    prerender: {\n      type: Number,\n      default: 0,\n    },\n\n    emitUpdate: {\n      type: Boolean,\n      default: false,\n    },\n  },\n\n  emits: [\"visible\", \"hidden\", \"resize\", \"update\", \"bottom\"],\n\n  data() {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null,\n    };\n  },\n\n  computed: {\n    sizes() {\n      if (this.itemSize === null) {\n        const sizes = {\n          \"-1\": { accumulator: 0 },\n        };\n        const items = this.items;\n        const field = this.sizeField;\n        const minItemSize = this.minItemSize;\n        let computedMinSize = 10000;\n        let accumulator = 0;\n        let current;\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize;\n          if (current < computedMinSize) {\n            computedMinSize = current;\n          }\n          accumulator += current;\n          sizes[i] = { accumulator, size: current };\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize;\n        return sizes;\n      }\n      return [];\n    },\n\n    simpleArray,\n  },\n\n  watch: {\n    items() {\n      this.updateVisibleItems(true);\n    },\n\n    pageMode() {\n      this.applyPageMode();\n      this.updateVisibleItems(false);\n    },\n\n    sizes: {\n      handler() {\n        this.updateVisibleItems(false);\n      },\n      deep: true,\n    },\n  },\n\n  created() {\n    this.$_startIndex = 0;\n    this.$_endIndex = 0;\n    this.$_views = new Map();\n    this.$_unusedViews = new Map();\n    this.$_scrollDirty = false;\n    this.$_lastUpdateScrollPosition = 0;\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true;\n      this.updateVisibleItems(false);\n    }\n  },\n\n  mounted() {\n    this.applyPageMode();\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false;\n      this.updateVisibleItems(true);\n      this.ready = true;\n    });\n  },\n\n  beforeUnmount() {\n    this.removeListeners();\n  },\n\n  methods: {\n    addView(pool, index, item, key, type) {\n      const view = {\n        item,\n        position: 0,\n      };\n      view.nr = {\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      };\n      pool.push(view);\n      return view;\n    },\n\n    unuseView(view, fake = false) {\n      const unusedViews = this.$_unusedViews;\n      const type = view.nr.type;\n      let unusedPool = unusedViews.get(type);\n      if (!unusedPool) {\n        unusedPool = [];\n        unusedViews.set(type, unusedPool);\n      }\n      unusedPool.push(view);\n      if (!fake) {\n        view.nr.used = false;\n        view.position = -9999;\n        this.$_views.delete(view.nr.key);\n      }\n    },\n\n    handleResize() {\n      this.$emit(\"resize\");\n      if (this.ready) this.updateVisibleItems(false);\n    },\n\n    handleScroll(event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true;\n        requestAnimationFrame(() => {\n          this.$_scrollDirty = false;\n          const { continuous } = this.updateVisibleItems(false, true);\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout);\n            this.$_refreshTimout = setTimeout(this.handleScroll, 100);\n          }\n        });\n      }\n    },\n\n    handleVisibilityChange(isVisible, entry) {\n      if (this.ready) {\n        if (\n          isVisible ||\n          entry.boundingClientRect.width !== 0 ||\n          entry.boundingClientRect.height !== 0\n        ) {\n          this.$emit(\"visible\");\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false);\n          });\n        } else {\n          this.$emit(\"hidden\");\n        }\n      }\n    },\n\n    updateVisibleItems(checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize;\n      const minItemSize = this.$_computedMinItemSize;\n      const typeField = this.typeField;\n      const keyField = this.simpleArray ? null : this.keyField;\n      const items = this.items;\n      const count = items.length;\n      const sizes = this.sizes;\n      const views = this.$_views;\n      const unusedViews = this.$_unusedViews;\n      const pool = this.pool;\n      let startIndex, endIndex;\n      let totalSize;\n\n      if (!count) {\n        startIndex = endIndex = totalSize = 0;\n      } else if (this.$_prerender) {\n        startIndex = 0;\n        endIndex = this.prerender;\n        totalSize = null;\n      } else {\n        const scroll = this.getScroll();\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition;\n          if (positionDiff < 0) positionDiff = -positionDiff;\n          if (\n            (itemSize === null && positionDiff < minItemSize) ||\n            positionDiff < itemSize\n          ) {\n            return {\n              continuous: true,\n            };\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start;\n\n        const buffer = this.buffer;\n        scroll.start -= buffer;\n        scroll.end += buffer;\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h;\n          let a = 0;\n          let b = count - 1;\n          let i = ~~(count / 2);\n          let oldI;\n\n          // Searching for startIndex\n          do {\n            oldI = i;\n            h = sizes[i].accumulator;\n            if (h < scroll.start) {\n              a = i;\n            } else if (\n              i < count - 1 &&\n              sizes[i + 1].accumulator > scroll.start\n            ) {\n              b = i;\n            }\n            i = ~~((a + b) / 2);\n          } while (i !== oldI);\n          i < 0 && (i = 0);\n          startIndex = i;\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator;\n\n          // Searching for endIndex\n          for (\n            endIndex = i;\n            endIndex < count && sizes[endIndex].accumulator < scroll.end;\n            endIndex++\n          );\n          if (endIndex === -1) {\n            endIndex = items.length - 1;\n          } else {\n            endIndex++;\n            // Bounds\n            endIndex > count && (endIndex = count);\n          }\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize);\n          endIndex = Math.ceil(scroll.end / itemSize);\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0);\n          endIndex > count && (endIndex = count);\n\n          totalSize = count * itemSize;\n        }\n      }\n\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError();\n      }\n\n      this.totalSize = totalSize;\n\n      let view;\n\n      const continuous =\n        startIndex <= this.$_endIndex && endIndex >= this.$_startIndex;\n\n      if (this.$_continuous !== continuous) {\n        if (continuous) {\n          views.clear();\n          unusedViews.clear();\n          for (let i = 0, l = pool.length; i < l; i++) {\n            view = pool[i];\n            this.unuseView(view);\n          }\n        }\n        this.$_continuous = continuous;\n      } else if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i];\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = items.findIndex((item) =>\n                keyField\n                  ? item[keyField] === view.item[keyField]\n                  : item === view.item\n              );\n            }\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index === -1 ||\n              view.nr.index < startIndex ||\n              view.nr.index >= endIndex\n            ) {\n              this.unuseView(view);\n            }\n          }\n        }\n      }\n\n      const unusedIndex = continuous ? null : new Map();\n\n      let item, type, unusedPool;\n      let v;\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i];\n        const key = keyField ? item[keyField] : item;\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`);\n        }\n        view = views.get(key);\n\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view);\n          continue;\n        }\n\n        // No view assigned to item\n        if (!view) {\n          type = item[typeField];\n          unusedPool = unusedViews.get(type);\n\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop();\n              view.item = item;\n              view.nr.used = true;\n              view.nr.index = i;\n              view.nr.key = key;\n              view.nr.type = type;\n            } else {\n              view = this.addView(pool, i, item, key, type);\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0;\n\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type);\n              this.unuseView(view, true);\n              unusedPool = unusedViews.get(type);\n            }\n\n            view = unusedPool[v];\n            view.item = item;\n            view.nr.used = true;\n            view.nr.index = i;\n            view.nr.key = key;\n            view.nr.type = type;\n            unusedIndex.set(type, v + 1);\n            v++;\n          }\n          views.set(key, view);\n        } else {\n          view.nr.used = true;\n          view.item = item;\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator;\n        } else {\n          view.position = i * itemSize;\n        }\n      }\n\n      this.$_startIndex = startIndex;\n      this.$_endIndex = endIndex;\n\n      if (this.emitUpdate) this.$emit(\"update\", startIndex, endIndex);\n\n      if (endIndex === this.items.length)\n        this.$emit(\"bottom\", startIndex, endIndex);\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer);\n      this.$_sortTimer = setTimeout(this.sortViews, 300);\n\n      return {\n        continuous,\n      };\n    },\n\n    getListenerTarget() {\n      let target = scrollParent(this.$el);\n      // Fix global scroll target for Chrome and Safari\n      if (\n        window.document &&\n        (target === window.document.documentElement ||\n          target === window.document.body)\n      ) {\n        target = window;\n      }\n      return target;\n    },\n\n    getScroll() {\n      const { $el: el, direction } = this;\n      const isVertical = direction === \"vertical\";\n      let scrollState;\n\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect();\n        const boundsSize = isVertical ? bounds.height : bounds.width;\n        let start = -(isVertical ? bounds.top : bounds.left);\n        let size = isVertical ? window.innerHeight : window.innerWidth;\n        if (start < 0) {\n          size += start;\n          start = 0;\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start;\n        }\n        scrollState = {\n          start,\n          end: start + size,\n        };\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight,\n        };\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth,\n        };\n      }\n\n      return scrollState;\n    },\n\n    applyPageMode() {\n      if (this.pageMode) {\n        this.addListeners();\n      } else {\n        this.removeListeners();\n      }\n    },\n\n    addListeners() {\n      this.listenerTarget = this.getListenerTarget();\n      this.listenerTarget.addEventListener(\n        \"scroll\",\n        this.handleScroll,\n        supportsPassive\n          ? {\n              passive: true,\n            }\n          : false\n      );\n      this.listenerTarget.addEventListener(\"resize\", this.handleResize);\n    },\n\n    removeListeners() {\n      if (!this.listenerTarget) {\n        return;\n      }\n\n      this.listenerTarget.removeEventListener(\"scroll\", this.handleScroll);\n      this.listenerTarget.removeEventListener(\"resize\", this.handleResize);\n\n      this.listenerTarget = null;\n    },\n\n    scrollToItem(index) {\n      let scroll;\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0;\n      } else {\n        scroll = index * this.itemSize;\n      }\n      this.scrollToPosition(scroll);\n    },\n\n    scrollToPosition(position) {\n      if (this.direction === \"vertical\") {\n        this.$el.scrollTop = position;\n      } else {\n        this.$el.scrollLeft = position;\n      }\n    },\n\n    itemsLimitError() {\n      setTimeout(() => {\n        console.log(\n          \"It seems the scroller element isn't scrolling, so it tries to render all the items at once.\",\n          \"Scroller:\",\n          this.$el\n        );\n        console.log(\n          \"Make sure the scroller has a fixed height (or width) and 'overflow-y' (or 'overflow-x') set to 'auto' so it can scroll correctly and only render the items visible in the scroll viewport.\"\n        );\n      });\n      throw new Error(\"Rendered items limit reached\");\n    },\n\n    sortViews() {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index);\n    },\n  },\n});\n</script>\n\n<style>\n.vue-recycle-scroller {\n  position: relative;\n}\n\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n  overflow-x: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal {\n  display: flex;\n}\n\n.vue-recycle-scroller__slot {\n  flex: auto 0 0;\n}\n\n.vue-recycle-scroller__item-wrapper {\n  flex: 1;\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n}\n\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n  width: 100%;\n}\n\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n  height: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-vertical\n  .vue-recycle-scroller__item-view {\n  width: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-horizontal\n  .vue-recycle-scroller__item-view {\n  height: 100%;\n}\n</style>\n","<template>\n  <RecycleScroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    key-field=\"id\"\n    v-bind=\"$attrs\"\n    @resize=\"onScrollerResize\"\n    @visible=\"onScrollerVisible\"\n    v-on=\"listeners\"\n  >\n    <template #default=\"{ item: itemWithSize, index, active }\">\n      <slot\n        v-bind=\"{\n          item: itemWithSize.item,\n          index,\n          active,\n          itemWithSize\n        }\"\n      />\n    </template>\n    <template #before>\n      <slot name=\"before\" />\n    </template>\n    <template #after>\n      <slot name=\"after\" />\n    </template>\n  </RecycleScroller>\n</template>\n\n<script>\nimport RecycleScroller from './RecycleScroller.vue'\nimport { props, simpleArray } from './common'\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    RecycleScroller,\n  },\n\n  provide () {\n    let vscrollResizeObserver = undefined\n\n    if (typeof ResizeObserver !== 'undefined') {\n      vscrollResizeObserver = new ResizeObserver(entries => {\n        for (const entry of entries) {\n          if (entry.target) {\n            const event = new CustomEvent('resize', {\n                detail: {\n                  contentRect: entry.contentRect,\n                },\n              },\n            )\n            entry.target.dispatchEvent(event)\n          }\n        }\n      })\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver,\n      onUpdateScroll: (cb) => this.vScrollMap.push(cb),\n    }\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    ...props,\n\n    minItemSize: {\n      type: [Number, String],\n      required: true,\n    },\n  },\n\n  emits: ['vscroll:update', 'resize', 'visible'],\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        validSizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n      vScrollMap: [],\n    }\n  },\n\n  computed: {\n    simpleArray,\n\n    itemsWithSize () {\n      const result = []\n      const { items, keyField, simpleArray } = this\n      const sizes = this.vscrollData.sizes\n      for (let i = 0; i < items.length; i++) {\n        const item = items[i]\n        const id = simpleArray ? i : item[keyField]\n        let size = sizes[id]\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0\n        }\n        result.push({\n          item,\n          id,\n          size,\n        })\n      }\n      return result\n    },\n\n    listeners () {\n      const listeners = {}\n\n      for (const key in this.$attrs) {\n        if (key.startsWith('on')) {\n          if (key !== 'onResize' && key !== 'onVisible') {\n            listeners[key] = this.$attrs\n          }\n        }\n      }\n\n      return listeners\n    },\n  },\n\n  watch: {\n    items () {\n      this.forceUpdate(false)\n    },\n\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value\n      },\n      immediate: true,\n    },\n\n    direction (value) {\n      this.forceUpdate(true)\n    },\n  },\n\n  created () {\n    this.$_updates = []\n    this.$_undefinedSizes = 0\n    this.$_undefinedMap = {}\n  },\n\n  activated () {\n    this.vscrollData.active = true\n  },\n\n  deactivated () {\n    this.vscrollData.active = false\n  },\n\n  methods: {\n    onScrollerResize () {\n      const scroller = this.$refs.scroller\n      if (scroller) {\n        this.forceUpdate()\n      }\n      this.$emit('resize')\n    },\n\n    onScrollerVisible () {\n      this.vScrollUpdate(false)\n      this.$emit('visible')\n    },\n\n    vScrollUpdate(force = false) {\n      const data = { force }\n      this.$emit('vscroll:update', data)\n\n      this.vScrollMap.forEach(callback => callback(data))\n    },\n\n    forceUpdate (clear = true) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.validSizes = {}\n      }\n      this.vScrollUpdate(true)\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller\n      if (scroller) scroller.scrollToItem(index)\n    },\n\n    getItemSize (item, index = undefined) {\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\n      return this.vscrollData.sizes[id] || 0\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return\n      this.$_scrollingToBottom = true\n      const el = this.$el\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false\n            } else {\n              requestAnimationFrame(cb)\n            }\n          })\n        }\n        requestAnimationFrame(cb)\n      })\n    },\n  },\n}\n</script>\n","<template>\n  <RecycleScroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    key-field=\"id\"\n    v-bind=\"$attrs\"\n    @resize=\"onScrollerResize\"\n    @visible=\"onScrollerVisible\"\n    v-on=\"listeners\"\n  >\n    <template #default=\"{ item: itemWithSize, index, active }\">\n      <slot\n        v-bind=\"{\n          item: itemWithSize.item,\n          index,\n          active,\n          itemWithSize\n        }\"\n      />\n    </template>\n    <template #before>\n      <slot name=\"before\" />\n    </template>\n    <template #after>\n      <slot name=\"after\" />\n    </template>\n  </RecycleScroller>\n</template>\n\n<script>\nimport RecycleScroller from './RecycleScroller.vue'\nimport { props, simpleArray } from './common'\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    RecycleScroller,\n  },\n\n  provide () {\n    let vscrollResizeObserver = undefined\n\n    if (typeof ResizeObserver !== 'undefined') {\n      vscrollResizeObserver = new ResizeObserver(entries => {\n        for (const entry of entries) {\n          if (entry.target) {\n            const event = new CustomEvent('resize', {\n                detail: {\n                  contentRect: entry.contentRect,\n                },\n              },\n            )\n            entry.target.dispatchEvent(event)\n          }\n        }\n      })\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver,\n      onUpdateScroll: (cb) => this.vScrollMap.push(cb),\n    }\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    ...props,\n\n    minItemSize: {\n      type: [Number, String],\n      required: true,\n    },\n  },\n\n  emits: ['vscroll:update', 'resize', 'visible'],\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        validSizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n      vScrollMap: [],\n    }\n  },\n\n  computed: {\n    simpleArray,\n\n    itemsWithSize () {\n      const result = []\n      const { items, keyField, simpleArray } = this\n      const sizes = this.vscrollData.sizes\n      for (let i = 0; i < items.length; i++) {\n        const item = items[i]\n        const id = simpleArray ? i : item[keyField]\n        let size = sizes[id]\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0\n        }\n        result.push({\n          item,\n          id,\n          size,\n        })\n      }\n      return result\n    },\n\n    listeners () {\n      const listeners = {}\n\n      for (const key in this.$attrs) {\n        if (key.startsWith('on')) {\n          if (key !== 'onResize' && key !== 'onVisible') {\n            listeners[key] = this.$attrs\n          }\n        }\n      }\n\n      return listeners\n    },\n  },\n\n  watch: {\n    items () {\n      this.forceUpdate(false)\n    },\n\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value\n      },\n      immediate: true,\n    },\n\n    direction (value) {\n      this.forceUpdate(true)\n    },\n  },\n\n  created () {\n    this.$_updates = []\n    this.$_undefinedSizes = 0\n    this.$_undefinedMap = {}\n  },\n\n  activated () {\n    this.vscrollData.active = true\n  },\n\n  deactivated () {\n    this.vscrollData.active = false\n  },\n\n  methods: {\n    onScrollerResize () {\n      const scroller = this.$refs.scroller\n      if (scroller) {\n        this.forceUpdate()\n      }\n      this.$emit('resize')\n    },\n\n    onScrollerVisible () {\n      this.vScrollUpdate(false)\n      this.$emit('visible')\n    },\n\n    vScrollUpdate(force = false) {\n      const data = { force }\n      this.$emit('vscroll:update', data)\n\n      this.vScrollMap.forEach(callback => callback(data))\n    },\n\n    forceUpdate (clear = true) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.validSizes = {}\n      }\n      this.vScrollUpdate(true)\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller\n      if (scroller) scroller.scrollToItem(index)\n    },\n\n    getItemSize (item, index = undefined) {\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\n      return this.vscrollData.sizes[id] || 0\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return\n      this.$_scrollingToBottom = true\n      const el = this.$el\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false\n            } else {\n              requestAnimationFrame(cb)\n            }\n          })\n        }\n        requestAnimationFrame(cb)\n      })\n    },\n  },\n}\n</script>\n","import { createVNode, nextTick } from 'vue';\n\nexport default {\n  name: 'DynamicScrollerItem',\n\n  inject: [\n    'vscrollData',\n    'vscrollParent',\n    'onUpdateScroll',\n    'vscrollResizeObserver',\n  ],\n\n  props: {\n    item: {\n      required: true,\n    },\n\n    watchData: {\n      type: Boolean,\n      default: false,\n    },\n\n    /**\n     * Indicates if the view is actively used to display an item.\n     */\n    active: {\n      type: Boolean,\n      required: true,\n    },\n\n    index: {\n      type: Number,\n      default: undefined,\n    },\n\n    sizeDependencies: {\n      type: [Array, Object],\n      default: null,\n    },\n\n    emitResize: {\n      type: Boolean,\n      default: false,\n    },\n\n    tag: {\n      type: String,\n      default: 'div',\n    },\n  },\n\n  computed: {\n    id () {\n      return this.vscrollData.simpleArray ? this.index : this.item[this.vscrollData.keyField];\n    },\n\n    size () {\n      return (this.vscrollData.validSizes[this.id] && this.vscrollData.sizes[this.id]) || 0;\n    },\n\n    finalActive () {\n      return this.active && this.vscrollData.active;\n    },\n  },\n\n  watch: {\n    watchData: 'updateWatchData',\n\n    id () {\n      if (!this.size) {\n        this.onDataUpdate();\n      }\n    },\n\n    finalActive (value) {\n      if (!this.size) {\n        if (value) {\n          if (!this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes++;\n            this.vscrollParent.$_undefinedMap[this.id] = true;\n          }\n        } else {\n          if (this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes--;\n            this.vscrollParent.$_undefinedMap[this.id] = false;\n          }\n        }\n      }\n\n      if (this.vscrollResizeObserver) {\n        if (value) {\n          this.observeSize();\n        } else {\n          this.unobserveSize();\n        }\n      } else if (value && this.$_pendingVScrollUpdate === this.id) {\n        this.updateSize();\n      }\n    },\n  },\n\n  created () {\n    if (this.$isServer) return;\n\n    this.$_forceNextVScrollUpdate = null;\n    this.updateWatchData();\n\n    if (!this.vscrollResizeObserver) {\n      for (const k in this.sizeDependencies) {\n        this.$watch(() => this.sizeDependencies[k], this.onDataUpdate);\n      }\n\n      this.onUpdateScroll('vscroll:update', this.onVscrollUpdate);\n    }\n  },\n\n  mounted () {\n    if (this.vscrollData.active) {\n      this.updateSize();\n      this.observeSize();\n    }\n  },\n\n  beforeUnmount () {\n    this.unobserveSize();\n  },\n\n  methods: {\n    updateSize () {\n      if (this.finalActive) {\n        if (this.$_pendingSizeUpdate !== this.id) {\n          this.$_pendingSizeUpdate = this.id;\n          this.$_forceNextVScrollUpdate = null;\n          this.$_pendingVScrollUpdate = null;\n          this.computeSize(this.id);\n        }\n      } else {\n        this.$_forceNextVScrollUpdate = this.id;\n      }\n    },\n\n    updateWatchData () {\n      if (this.watchData) {\n        this.$_watchData = this.$watch('data', () => {\n          this.onDataUpdate();\n        }, {\n          deep: true,\n        });\n      } else if (this.$_watchData) {\n        this.$_watchData();\n        this.$_watchData = null;\n      }\n    },\n\n    onVscrollUpdate ({ force }) {\n      // If not active, sechedule a size update when it becomes active\n      if (!this.finalActive && force) {\n        this.$_pendingVScrollUpdate = this.id;\n      }\n\n      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {\n        this.updateSize();\n      }\n    },\n\n    onDataUpdate () {\n      this.updateSize();\n    },\n\n    computeSize (id) {\n      nextTick(() => {\n        if (this.id === id) {\n          const width = this.$el.offsetWidth;\n          const height = this.$el.offsetHeight;\n          this.applySize(width, height);\n        }\n        this.$_pendingSizeUpdate = null;\n      }).then();\n    },\n\n    applySize (width, height) {\n      const size = Math.round(this.vscrollParent.direction === 'vertical' ? height : width);\n      if (size && this.size !== size) {\n        if (this.vscrollParent.$_undefinedMap[this.id]) {\n          this.vscrollParent.$_undefinedSizes--;\n          this.vscrollParent.$_undefinedMap[this.id] = undefined;\n        }\n        this.vscrollData.sizes[this.id] = size;\n        this.vscrollData.validSizes[this.id] = true;\n        if (this.emitResize) this.$emit('resize', this.id);\n      }\n    },\n\n    observeSize () {\n      if (!this.vscrollResizeObserver) return;\n      this.vscrollResizeObserver.observe(this.$el.parentNode);\n      this.$el.parentNode.addEventListener('resize', this.onResize);\n    },\n\n    unobserveSize () {\n      if (!this.vscrollResizeObserver) return;\n      this.vscrollResizeObserver.unobserve(this.$el.parentNode);\n      this.$el.parentNode.removeEventListener('resize', this.onResize);\n    },\n\n    onResize (event) {\n      const { width, height } = event.detail.contentRect;\n      this.applySize(width, height);\n    },\n  },\n\n  render () {\n    return createVNode(this.tag, null, this.$slots.default());\n  },\n};\n","import config from './config'\n\nimport RecycleScroller from './components/RecycleScroller.vue'\nimport DynamicScroller from './components/DynamicScroller.vue'\nimport DynamicScrollerItem from './components/DynamicScrollerItem.js'\nimport { version } from '../package.json'\n\nexport {\n  RecycleScroller,\n  DynamicScroller,\n  DynamicScrollerItem,\n}\n\nfunction registerComponents (app, prefix) {\n  app.component(`${prefix}recycle-scroller`, RecycleScroller)\n  app.component(`${prefix}RecycleScroller`, RecycleScroller)\n  app.component(`${prefix}dynamic-scroller`, DynamicScroller)\n  app.component(`${prefix}DynamicScroller`, DynamicScroller)\n  app.component(`${prefix}dynamic-scroller-item`, DynamicScrollerItem)\n  app.component(`${prefix}DynamicScrollerItem`, DynamicScrollerItem)\n}\n\nconst plugin = {\n  version,\n  install (app, options) {\n    const finalOptions = Object.assign({}, {\n      installComponents: true,\n      componentsPrefix: '',\n    }, options)\n\n    for (const key in finalOptions) {\n      if (typeof finalOptions[key] !== 'undefined') {\n        config[key] = finalOptions[key]\n      }\n    }\n\n    if (finalOptions.installComponents) {\n      registerComponents(app, finalOptions.componentsPrefix)\n    }\n  },\n}\n\nexport default plugin\n"],"names":["itemsLimit","isIE","initCompat","init","ua","window","navigator","userAgent","msie","indexOf","parseInt","substring","rv","edge","getInternetExplorerVersion","script","name","props","showTrigger","type","Boolean","default","emits","[object Object]","emit","_w","_h","elRef","ref","_resizeObject","compareAndNotify","value","offsetWidth","offsetHeight","width","height","addResizeHandlers","contentDocument","defaultView","addEventListener","onMounted","object","document","createElement","setAttribute","onload","appendChild","data","onBeforeUnmount","removeEventListener","removeChild","_hoisted_1","class","tabindex","_typeof","obj","Symbol","iterator","constructor","prototype","_defineProperties","target","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_toConsumableArray","arr","Array","isArray","arr2","_arrayWithoutHoles","iter","toString","call","from","_iterableToArray","TypeError","_nonIterableSpread","render","_ctx","_cache","$props","$setup","$data","$options","openBlock","createBlock","__file","install","app","component","VisibilityState","el","options","vnode","instance","Constructor","_classCallCheck","this","observer","frozen","createObserver","protoProps","staticProps","_this","destroyObserver","callback","result","entry","once","throttle","_leading","throttleOptions","leading","delay","timeout","lastState","currentArgs","arguments","undefined","throttled","state","_len","args","_key","apply","concat","clearTimeout","setTimeout","_clear","oldResult","IntersectionObserver","entries","intersectingEntry","find","e","isIntersecting","intersectionRatio","threshold","intersection","observe","disconnect","get","mounted","_ref2","console","warn","_vue_visibilityState","unmounted","ObserveVisibility","componentUpdated","_ref3","deepEqual","val1","val2","oldValue","items","required","keyField","String","direction","validator","includes","scrollParent","node","regex","style","prop","getComputedStyle","getPropertyValue","scroll","test","overflow","HTMLElement","SVGElement","ps","parents","parentNode","scrollingElement","documentElement","simpleArray","supportsPassive","opts","uid","defineComponent","components","ResizeObserver","directives","itemSize","Number","minItemSize","sizeField","typeField","buffer","pageMode","prerender","emitUpdate","pool","totalSize","ready","hoverKey","computed","sizes","current","accumulator","field","computedMinSize","l","size","$_computedMinItemSize","watch","updateVisibleItems","applyPageMode","handler","deep","created","$_startIndex","$_endIndex","$_views","Map","$_unusedViews","$_scrollDirty","$_lastUpdateScrollPosition","$_prerender","$nextTick","beforeUnmount","removeListeners","methods","addView","index","item","view","position","nr","id","used","push","unuseView","fake","unusedViews","unusedPool","set","delete","handleResize","$emit","handleScroll","event","requestAnimationFrame","_this2","continuous","$_refreshTimout","handleVisibilityChange","isVisible","boundingClientRect","_this3","checkItem","startIndex","endIndex","checkPositionDiff","count","views","getScroll","positionDiff","start","end","oldI","a","b","Math","ceil","config","itemsLimitError","$_continuous","clear","findIndex","v","unusedIndex","Error","pop","$_sortTimer","sortViews","getListenerTarget","$el","body","scrollState","isVertical","bounds","getBoundingClientRect","boundsSize","top","left","innerHeight","innerWidth","scrollTop","clientHeight","scrollLeft","clientWidth","addListeners","listenerTarget","passive","scrollToItem","scrollToPosition","log","_this4","sort","viewA","viewB","_createBlock","before","_renderSlot","_createVNode","onMouseenter","onMouseleave","active","after","_hoisted_2","onNotify","RecycleScroller","provide","vscrollResizeObserver","CustomEvent","detail","contentRect","dispatchEvent","vscrollData","vscrollParent","onUpdateScroll","cb","vScrollMap","inheritAttrs","validSizes","itemsWithSize","$_undefinedMap","listeners","$attrs","startsWith","forceUpdate","immediate","$_updates","$_undefinedSizes","activated","deactivated","onScrollerResize","$refs","scroller","onScrollerVisible","vScrollUpdate","force","forEach","getItemSize","scrollToBottom","$_scrollingToBottom","scrollHeight","_mergeProps","onResize","onVisible","_toHandlers","itemWithSize","inject","watchData","sizeDependencies","emitResize","tag","finalActive","onDataUpdate","observeSize","unobserveSize","$_pendingVScrollUpdate","updateSize","$isServer","$_forceNextVScrollUpdate","updateWatchData","k","$watch","onVscrollUpdate","$_pendingSizeUpdate","computeSize","$_watchData","nextTick","applySize","then","round","unobserve","createVNode","$slots","plugin","version","finalOptions","assign","installComponents","componentsPrefix","prefix","DynamicScroller","DynamicScrollerItem","registerComponents"],"mappings":"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"}